# 相关协议

## TCP 协议是流式协议

很多读者从接触网络知识以来，应该听说过这句话：TCP
协议是流式协议。那么这句话到底是什么意思呢？所谓流式协议，即协议的内容是像流水一样的字节流，内容与内容之间没有明确的分界标志，需要我们人为地去给这些协议划分边界。

举个例子，A 与 B 进行 TCP 通信，A 先后给 B 发送了一个 100 字节和 200 字节的数据包，那么 B 是如何收到呢？B 可能先收到 100
字节，再收到 200 字节；也可能先收到 50 字节，再收到 250 字节；或者先收到 100 字节，再收到 100 字节，再收到 100 字节；或者先收到
20 字节，再收到 20 字节，再收到 60 字节，再收到 100 字节，再收到 50 字节，再收到 50 字节......

不知道读者看出规律没有？规律就是 A 一共给 B 发送了 300 字节，B 可能以一次或者多次任意形式的总数为 300 字节收到。假设 A 给 B
发送两个大小分别是 100 字节和 200 字节的数据包，作为发送方的 A 来说，A 是知道如何划分这两个数据包的界限的，但是对于 B
来说，如果不人为规定多少字节作为一个数据包，B 每次是不知道应该把收到的数据中多少字节作为一个有效的数据包的，而规定每次把多少数据当成一个包就是协议格式定义的内容之一。

经常会有新手写出类似下面这样的代码：

**发送端：**

```c++
//...省略创建socket，建立连接等部分不相关的逻辑...
char buf[] = "the quick brown fox jumps over a lazy dog.";
int n = send(socket, buf, strlen(buf), 0);
//...省略出错处理逻辑...
```

**接收端：**

```c++
//省略创建socket，建立连接等部分不相关的逻辑...
char recvBuf[50] = { 0 };
int n = recv(socket, recvBuf, 50, 0);
//省略出错处理逻辑...
printf("recvBuf: %s", recvBuf);
```

为了专注问题本身的讨论，我这里省略掉了建立连接和错误处理的逻辑。上述代码中发送端给接收端发送了一串字符”the quick brown fox
jumps over a lazy dog.“，接收端收到后将其打印出来。

类似这样的代码在本机一般会工作的很好，接收端也如期打印出来预料的字符串，但是一放到局域网或者公网环境就出问题了，即接收端可能打印出来字符串并不完整；如果发送端连续多次发送字符串，接收端会打印出来的字符串不完整或出现乱码。不完整的原因很好理解，即对端某次收到的数据小于完整字符串的长度，recvBuf
数组开始被清空成 \0，收到部分字符串后，该字符串的末尾仍然是 \0，printf 函数寻找以 \0
为结束标志的字符结束输出；乱码的原因是如果某次收入的数据不仅包含一个完整的字符串，还包含下一个字符串部分内容，那么 recvBuf
数组将会被填满，printf 函数输出时仍然会寻找以 \0 为结束标志的字符结束输出，这样读取的内存就越界了，一直找到 \0
为止，而越界后的内存可能是一些不可读字符，显示出来后就乱码了。

我举这个例子的目的是希望你能对“ TCP
协议是流式协议”有一个直观的认识。正因为如此，我们需要人为地在发送端和接收端规定每一次的字节流边界，以便接收端知道从什么位置取出多少字节来当成一个数据包去解析，这是我们设计网络通信协议格式要做的工作之一。

### 如何解决粘包问题

网络通信程序实际开发中，或者技术面试时，面试官通常会问的比较多的一个问题是：网络通信时，如何解决粘包？

有的面试官可能会这么问：网络通信时，如何解决粘包、丢包或者包乱序问题？这个问题其实是面试官在考察面试者的网络基础知识，如果是
TCP 协议，在大多数场景下，是不存在丢包和包乱序问题的，TCP 通信是可靠通信方式，TCP 协议栈通过序列号和包重传确认机制保证数据包的有序和一定被正确发到目的地；如果是
UDP 协议，如果不能接受少量丢包，那就要自己在 UDP 的基础上实现类似 TCP 这种有序和可靠传输机制了（例如 RTP 协议、RUDP
协议）。所以，问题拆解后，只剩下如何解决粘包的问题。

先来解释一下什么是粘包，所谓粘包就是连续给对端发送两个或者两个以上的数据包，对端在一次收取中收到的数据包数量可能大于 1
个，当大于 1 个时，可能是几个（包括一个）包加上某个包的部分，或者干脆就是几个完整的包在一起。当然，也可能收到的数据只是一个包的部分，这种情况一般也叫半包。

粘包示意图如下：
![img.png](.img/get-entangled-package.png)

无论是半包还是粘包问题，其根源是上文介绍中 TCP 协议是流式数据格式。解决问题的思路还是想办法从收到的数据中把包与包的边界给区分出来。那么如何区分呢？一般有三种分包方法：

**固定包长的数据包**

顾名思义，即每个协议包的长度都是固定的。举个例子，例如我们可以规定每个协议包的大小是 64 个字节，每次收满 64
个字节，就取出来解析（如果不够，就先存起来）。

这种通信协议的格式简单但灵活性差。如果包内容不足指定的字节数，剩余的空间需要填充特殊的信息，如
\0（如果不填充特殊内容，如何区分包里面的正常内容与填充信息呢？）；如果包内容超过指定字节数，又得分包分片，需要增加额外处理逻辑——在发送端进行分包分片，在接收端重新组装包片（分包和分片内容在接下来会详细介绍）。

**以指定字符（串）为包的结束标志**
这种协议包比较常见，即字节流中遇到特殊的符号值时就认为到一个包的末尾了。例如，我们熟悉的 FTP协议，发邮件的 SMTP
协议，一个命令或者一段数据后面加上"\r\n"（即所谓的 CRLF）表示一个包的结束。对端收到后，每遇到一个”\r\n“就把之前的数据当做一个数据包。

这种协议一般用于一些包含各种命令控制的应用中，其不足之处就是如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析。

**包头 + 包体格式**
这种格式的包一般分为两部分，即包头和包体，包头是固定大小的，且包头中必须含有一个字段来说明接下来的包体有多大。

例如：

```c++
struct msg_header
{
  int32_t bodySize;
  int32_t cmd;
};
```

这就是一个典型的包头格式，bodySize 指定了这个包的包体是多大。由于包头大小是固定的（这里是 size(int32_t) + sizeof(int32_t) =
8 字节），对端先收取包头大小字节数目（当然，如果不够还是先缓存起来，直到收够为止），然后解析包头，根据包头中指定的包体大小来收取包体，等包体收够了，就组装成一个完整的包来处理。在有些实现中，包头中的
bodySize可能被另外一个叫 packageSize 的字段代替，这个字段的含义是整个包的大小，这个时候，我们只要用 packageSize 减去包头大小（这里是
sizeof(msg_header)）就能算出包体的大小，原理同上。

> 在使用大多数网络库时，通常你需要根据协议格式自己给数据包分界和解析，一般的网络库不提供这种功能是出于需要支持不同的协议，由于协议的不确定性，因此没法预先提供具体解包代码。当然，这不是绝对的，也有一些网络库提供了这种功能。在
> Java Netty 网络框架中，提供了FixedLengthFrameDecoder 类去处理长度是定长的协议包，提供了 DelimiterBasedFrameDecoder
> 类去处理按特殊字符作为结束符的协议包，提供 ByteToMessageDecoder 去处理自定义格式的协议包（可用来处理包头 + 包体
> 这种格式的数据包），然而在继承 ByteToMessageDecoder 子类中你需要根据你的协议具体格式重写 decode() 方法来对数据包解包。

### 解包与处理

以包头 + 包体 这种格式的数据包来说明，处理流程如下：
![img.png](.img/decode-tcp-package.png)

假设我们的包头格式如下：

```c++
//强制1字节对齐
#pragma
pack(push, 1)
//协议头
struct msg_header
{
int32_t  bodysize;         //包体大小  
};
#pragma
pack(pop)
```

那么上面的流程实现代码如下：

```c++
//包最大字节数限制为10M
#define
MAX_PACKAGE_SIZE    10 * 1024 * 1024

void ChatSession::OnRead(const std::shared_ptr<TcpConnection>& conn, Buffer* pBuffer, Timestamp receivTime)
{
while (true)
{
//不够一个包头大小
if (pBuffer->readableBytes() < (size_t)sizeof(msg_header))
{
//LOGI << "buffer is not enough for a package header, pBuffer->readableBytes()=" << pBuffer->readableBytes() << ", sizeof(msg_header)=" << sizeof(msg_header);
return;
}

//取包头信息
msg_header header;
memcpy(&header, pBuffer->peek(), sizeof(msg_header));

//包头有错误，立即关闭连接
if (header.bodysize <= 0 || header.bodysize > MAX_PACKAGE_SIZE)
{
//客户端发非法数据包，服务器主动关闭之
LOGE("Illegal package, bodysize: %lld, close TcpConnection, client: %s", header.bodysize, conn->peerAddress().toIpPort().c_str());
conn->forceClose();
return;
}

//收到的数据不够一个完整的包
if (pBuffer->readableBytes() < (size_t)header.bodysize + sizeof(msg_header))
return;

pBuffer->retrieve(sizeof(msg_header));
//inbuf用来存放当前要处理的包
std::string inbuf;
inbuf.append(pBuffer->peek(), header.bodysize);
pBuffer->retrieve(header.bodysize);
//解包和业务处理
if (!Process(conn, inbuf.c_str(), inbuf.length()))
{
//客户端发非法数据包，服务器主动关闭之
LOGE("Process package error, close TcpConnection, client: %s", conn->peerAddress().toIpPort().c_str());
conn->forceClose();
return;
}
}// end while-loop
}
```

上述流程代码的处理过程和流程图中是一致的，pBuffer
这里是一个自定义的接收缓冲区，这里的代码，已经将收到的数据放入了这个缓冲区，所以判断当前已收取的字节数目只需要使用这个对象的相应方法即可。上述代码有些细节需要强调一下：

- 取包头时，你应该拷贝一份数据包头大小的数据出来，而不是从缓冲区 pBuffer 中直接将数据取出来（即取出来的数据从 pBuffer
  中移除），这是因为倘若接下来根据包头中的字段得到包体大小时，如果剩余数据不够一个包体大小，你又得把这个包头数据放回缓冲区。为了避免这种不必要的操作，只有缓冲区数据大小够整个包的大小（代码中：header.bodysize +
  sizeof(msg)）你才需要把整个包大小的数据从缓冲区移除，这也是这里的 pBuffer->peek() 方法 peek 单词的含义（中文可以翻译成”瞟一眼“或者”偷窥“）。

- 通过包头得到包体大小时，你一定要对 bodysize 的数值进行校验，我这里要求 bodysize 必须大于 0 且不大于 10 * 1024 * 1024（即
  10 M）。当然，你可以根据实际情况决定 bodysize 的上下限（包体大小是 0 字节的包在某些业务场景下是允许的）。记住，一定要判断这个上下限，因为假设这是一个非法的客户端发来的数据，其
  bodysize 设置了一个比较大的数值，例如 1 * 1024 * 1024 * 1024（即 1
  G），你的逻辑会让你一直缓存该客户端发来的数据，那么很快你的服务器内存将会被耗尽，操作系统在检测到你的进程占用内存达到一定阈值时会杀死你的进程，导致服务不能再正常对外服务。如果你判断了
  bodysize 字段是否满足你设置的上下限，对于非法的 bodysize，直接关闭这路连接即可。这也是服务的一种自我保护措施，避免因为非法数据包带来的损失。还有另外一种情况下
  bodysize 也可能不是预期的合理值，即因为网络环境差或者某次数据解析逻辑错误，导致后续的数据错位，把不该当包头数据的数据当成了包头，这个时候解析出来的
  bodysize 也可能不是合理值，同样，这种情形下也会被这段检验逻辑检测到，最终关闭连接。

- 不知道你有没有注意到整个判断包头、包体以及处理包的逻辑放在一个 while 循环里面，这是必要的。如果没有这个 while
  循环，当你一次性收到多个包时，你只会处理一个，下次接着处理就需要等到新一批数据来临时再次触发这个逻辑。这样造成的结果就是，对端给你发送了多个请求，你最多只能应答一个，后面的应答得等到对端再次给你发送数据时。这就是对粘包逻辑的正确处理。

以上逻辑和代码是最基本的粘包和半包处理机制，也就是所谓的技术上的解包处理逻辑。在理解它的基础之上，可以给解包拓展很多功能，例如，再给我们的协议包增加一个支持压缩的功能，包头变成下面这个样子：

```c++
#pragma pack(push, 1)
//协议头
struct msg_header
{
    char     compressflag;     //压缩标志，如果为1，则启用压缩，反之不启用压缩
    int32_t  originsize;       //包体压缩前大小
    int32_t  compresssize;     //包体压缩后大小
    char     reserved[16];	   //保留字段，用于将来拓展
};
#pragma pack(pop)
```

修改后的代码如下：

```c++
//包最大字节数限制为10M
#define
MAX_PACKAGE_SIZE    10 * 1024 * 1024

void ChatSession::OnRead(const std::shared_ptr<TcpConnection>& conn, Buffer* pBuffer, Timestamp receivTime)
{
while (true)
{
//不够一个包头大小
if (pBuffer->readableBytes() < (size_t)sizeof(msg_header))
{
//LOGI << "buffer is not enough for a package header, pBuffer->readableBytes()=" << pBuffer->readableBytes() << ", sizeof(msg_header)=" << sizeof(msg_header);
return;
}

//取包头信息
msg_header header;
memcpy(&header, pBuffer->peek(), sizeof(msg_header));

//数据包压缩过
if (header.compressflag == PACKAGE_COMPRESSED)
{
//包头有错误，立即关闭连接
if (header.compresssize <= 0 || header.compresssize > MAX_PACKAGE_SIZE ||
header.originsize <= 0 || header.originsize > MAX_PACKAGE_SIZE)
{
//客户端发非法数据包，服务器主动关闭之
LOGE("Illegal package, compresssize: %lld, originsize: %lld, close TcpConnection, client: %s", header.compresssize, header.originsize, conn->peerAddress().toIpPort().c_str());
conn->forceClose();
return;
}

//收到的数据不够一个完整的包
if (pBuffer->readableBytes() < (size_t)header.compresssize + sizeof(msg_header))
return;

pBuffer->retrieve(sizeof(msg_header));
std::string inbuf;
inbuf.append(pBuffer->peek(), header.compresssize);
pBuffer->retrieve(header.compresssize);
std::string destbuf;
if (!ZlibUtil::UncompressBuf(inbuf, destbuf, header.originsize))
{
LOGE("uncompress error, client: %s", conn->peerAddress().toIpPort().c_str());
conn->forceClose();
return;
}

//业务逻辑处理
if (!Process(conn, destbuf.c_str(), destbuf.length()))
{
//客户端发非法数据包，服务器主动关闭之
LOGE("Process error, close TcpConnection, client: %s", conn->peerAddress().toIpPort().c_str());
conn->forceClose();
return;
}
}
//数据包未压缩
else
{
//包头有错误，立即关闭连接
if (header.originsize <= 0 || header.originsize > MAX_PACKAGE_SIZE)
{
//客户端发非法数据包，服务器主动关闭之
LOGE("Illegal package, compresssize: %lld, originsize: %lld, close TcpConnection, client: %s", header.compresssize, header.originsize, conn->peerAddress().toIpPort().c_str());
conn->forceClose();
return;
}

//收到的数据不够一个完整的包
if (pBuffer->readableBytes() < (size_t)header.originsize + sizeof(msg_header))
return;

pBuffer->retrieve(sizeof(msg_header));
std::string inbuf;
inbuf.append(pBuffer->peek(), header.originsize);
pBuffer->retrieve(header.originsize);
//业务逻辑处理
if (!Process(conn, inbuf.c_str(), inbuf.length()))
{
//客户端发非法数据包，服务器主动关闭之
LOGE("Process error, close TcpConnection, client: %s", conn->peerAddress().toIpPort().c_str());
conn->forceClose();
return;
}
}// end else

}// end while-loop
}
```

这段代码先根据包头的压缩标志字段判断包体是否有压缩，如果有压缩，则取出包体大小去解压，解压后的数据才是真正的业务数据。整个程序执行流程图如下：
![img.png](.img/tcp-business-handle.png)

代码中有一个接收缓冲区变量 pBuffer。

## 从 struct 到 TLV——协议的演化历史

假设现在 A 与 B 之间要传输一个关于用户信息的数据包，可以将该数据包格式定义成如下形式：

```c++
#pragma pack(push, 1)
struct userinfo
{
    //命令号
    int32_t cmd;
    //用户性别
    char    gender;
    //用户昵称
    char	name[8];
};
#pragma pack(pop)
```

相信很多读者曾经都定义过这样的协议，这种数据结构简单明了，对端只要直接拷贝按字段解析就可以了。但是，需求总是不断变化的，某一天根据新的需求需要在这个结构中增加一个字段表示用户的年龄，于是修改协议结构成：

```c++
#pragma pack(push, 1)
struct userinfo
{
    //命令号
    int32_t cmd;
    //用户性别
    char    gender;
    //用户昵称
    char	name[8];
    //用户年龄
    int32_t	age;
};
#pragma pack(pop)
```

问题并没有直接增加一个字段那么简单，新修改的协议格式导致旧的客户端无法兼容（旧的客户端已经分发出去），这个时候我们升级服务器端的协议格式成新的，会导致旧的客户端无法使用。所以我们在最初设计协议的时候，我们需要增加一个版本号字段，针对不同的版本来做不同的处理，即：

```c++
/**
 * 旧的协议，版本号是 1
 */
#pragma
pack(push, 1)
struct userinfo
{
//版本号
short version;
//命令号
int32_t cmd;
//用户性别
char gender;
//用户昵称
char name[8];
};
#pragma
pack(pop)

/**
 * 新的协议，版本号是 2
 */
#pragma
pack(push, 1)
struct userinfo
{
//版本号
short version;
//命令号
int32_t cmd;
//用户性别
char gender;
//用户昵称
char name[8];
//用户年龄
int32_t    age;
};
#pragma
pack(pop)
```

这样我们可以用以下伪码来兼容新旧协议：

```c++
//从包中读取一个 short 型字段
short version = <从包中读取一个 short 型字段>;
if (version == 1)
{
//当旧的协议格式进行处理
}
else if (version == 2)
{
//当新的协议格式进行处理
}
```

上述方法是一个兼容旧版协议的常见做法。但是这样也存在一个问题，如果我们的业务需求变化快，我们可能需要经常调整协议字段（增、删、改），这样我们的版本号数量会比较多，我们的代码会变成类似下面这种形式：

```c++
//从包中读取一个 short 型字段
short version = <从包中读取一个 short 型字段>;
if (version == 版本号1)
{
//对版本号1格式进行处理
}
else if (version == 版本号2)
{
//对版本号2格式进行处理
}
else if (version == 版本号3)
{
//对版本号3格式进行处理
}
else if (version == 版本号4)
{
//对版本号4格式进行处理
}
else if (version == 版本号5)
{
//对版本号5格式进行处理
}
...省略更多...
```

这只是考虑了协议顶层结构，还没有考虑更多复杂的嵌套结构，不管怎样，这样的代码会变得越来越难以维护。

> 这里只是为了说明问题，实际开发中，建议在设计协议时尽量考虑周全，避免反复修改协议结构。

上述协议格式还存在另外一个问题，对于 name 字段，其长度为 8
个字节，这种定长的字段，长度大小不具有伸缩性，太长很多情况都用不完则造成内存和网络带宽的浪费，太短则某些情况下不够用。那么有没有什么方法来解决呢？

方法是有的，对于字符串类型的字段，我们可以在该字段前面加一个表示字符串长度（length）的标志，那么上面的协议在内存中的状态可以表示成如下图示：
![img.png](.img/string-length-flag.png)

这种方法解决了定义字符串类型时太长浪费太短不够用的问题，但是没有解决修改协议（如新增字段）需要兼容众多旧版本的问题，对于这个问题，我们可以通过在每个字段前面加一个
type 类型来解决，我们可以使用一个 char 类型来表示常用的类型，规定如下：

| 类型               | Type值 | 类型描述      |
|------------------|-------|-----------|
| bool             | 0     | 布尔值       |
| char             | 1     | char 型    |
| int16            | 2     | 16 位整型    |
| int32            | 3     | 32 位整型    |
| int64            | 4     | 64 位整形    |
| string           | 5     | 字符串或二进制序列 |
| list             | 6     | 列表        |
| map              | 7     | map       |
| 更多自定义类型省略......	 |       |           |

那么对于上述协议，其内存格式变成：
![img.png](.img/protocol-type.png)

这样，每个字段的类型就是自解释了。这就是所谓的 TLV（Type-Length-Value，有的资料也称 Tag-Length-Value，其设计思想来源于 ANS.1 规范中一种叫 BER（Basic Encoding Rules）的编码格式）。这种格式的协议，我们可以方便地增删和修改字段类型，程序解析时根据每个字段的 type 来得到字段的类型。

这里再根据笔者的经验多说几句，实际开发中 TLV 类型虽然易于扩展，但是也存在如下缺点：

- TLV 格式因为每个字段增加了一个 type 类型，导致所占空间增大；

- 我们在解析字段时需要额外增加一些判断 type 的逻辑，去判断字段的类型，做相应的处理，即：

```c++
//读取第一个字节得到 type
if (type == Type::BOOL)
{
    //bool型处理
}
else if (type == Type::CHAR)
{
    //char型处理
}
else if (type == Type::SHORT)
{
    //short型处理
}
...更多类型省略...
```

如上代码所示，每个字段我们都需要有这样的逻辑判断，这样的编码方式是非常麻烦的。

- 即使我们知道了每个字段的技术类型（相对业务来说），每个字段的业务含义仍然需要我们制定文档格式，也就是说 TLV 格式只是做到了技术上自解释。

所以，在实际的开发中，完全遵循 TLV 格式的协议并不多，尤其是针对一些整型类型的字段，例如整型字段的大小一旦在知道类型后，其长度就是固定下来的，例如 short 类型占 2 个字节，int32 类型占 4 个字节，因此不必专门浪费一段空间去存储其长度信息。

TLV 格式还可以嵌套，如下图所示：
![img.png](.img/Type-Length-Value.png)

> 有的项目在 TLV 格式的基础上还扩展了一种叫 TTLV 格式的协议，即 Tag-Type-Length-Value，每个字段前面再增加一个 Tag 类型，这个时候 Type 表示数据类型，Tag 的含义由协议双方协定。

## 协议的分类
根据协议的内容是否是文本格式（即人为可读格式），我们将协议分为文本协议和二进制协议，像 http 协议的包头部分和 FTP 协议等都是典型的文本协议的例子。

### 协议设计工具
虽然 TLV 很简单，但是每搞一套新的协议都要从头编解码、调试，写编解码是一个毫无技术含量的枯燥体力活。在大量复制粘贴过程中，容易出错。

因此出现了一种叫 IDL（Interface Description Language）的语言规范，它是一种描述语言，也是一个中间语言，IDL 规范协议的使用类型，提供跨语言特性。可以定义一个描述协议格式的 IDL 文件，然后通过 IDL 工具分析 IDL 文件，就可以生成各种语言版本的协议代码。Google Protobuf 库自带的工具 protoc 就是这样一个工具。

### 整型数值的压缩
在实际设计协议时，整型数值（如 int32、int64）在协议字段中出现频率非常高，以上面介绍的 TLV 格式为例，L 代表每个字段的长度，假设用一个 int32 类型表示，int32 占 4 个字节，对于无符号的 int32 类型来说，其可表示的范围为 0 ~ 4294967295，实际用途中，我们不会用到太长的字段值，因此可以根据字段实际的 length 值使用 1 ~ n 个字节表示这个 int32 值。

在实际处理中，一个字节（Byte）的共有 8 位（bit），该字节的最高位我们用来作为标志位，用于说明一个整型数值是否到此字节结束，如果某个字节的最高位为 0 表示该整型值的内容到此字节结束，最高位为 1 表示表示下一个字节仍然是该整型值的内容。说的有点抽象，我们来看一个具体的例子。假设在一串字节流中，存在如下二进制数字表示某个整型值：

```text
第1个字节  第2个字节 第3个字节  第4个字节
10111011 11110000 01110000 11110111 ...其他省略...
```

如上图所示，第一个字节是 10111011 ，其最高位为 1，说明其下一个字节仍然属于表示该整型的序列，下一个字节是第二个字节 11110000，其最高位仍然是 1，再看第三个字节的内容 01110000，第三个字节的最高位是 0，因此表示这个整数的字节序列到此就结束了。假定我们压缩时的顺序是低位内容字节在内存地址较小的位置，高位内容在内存地址较大的位置，则将每个字节的标志位（最高位）去掉后，其值是：

```text
第3个字节  第2个字节 第1个字节 
1110000  1110000  0111011   => 11100 00111000 00111011
```

使用上述技巧进行压缩的整型，由于一个字节只使用低 7 位（最高位为标志位，一般称为“字节前导位”），一个 int32 的整型共 4 个字节（4 * 8 = 32）位，因此一个 int32 使用上述方法进行压缩其长度可能是 1 ~ 5 个字节。实际协议中，我们基本上很少遇到使用超过 3 个字节以上长度，因此这种压缩还是比较实用的（节省空间）。

有了上面的分析，对于一个无符号 int32 的整型的压缩算法如下，以下代码节选自 POCO C++ 库，代码格式略有调整：
```text
01 //poco-master\Foundation\src\BinaryWriter.cpp
02 //将一个 uint32 压缩成 1 ~ 5 个字节的算法
03 void BinaryWriter::write7BitEncoded(UInt32 value)
04 {
05 	 do
06	 {
07		 unsigned char c = (unsigned char) (value & 0x7F);
08		 value >>= 7;
09		 if (value) 
10			 c |= 0x80;
11			
12		 _ostr.write((const char*) &c, 1);
13	 }
14	 while (value);
15 }
```

上述代码对一个 uint32_t 整型 value 从低到高每次取 7 bit，判断下 value 的值在去掉 7 bit 后是否有剩余（非 0 则说明有剩余，代码第 8 和 9 行），如果则将当前字节最高 bit （标志位）设置为 1，这样得到一个字节的值后，放入字节流容器 _ostr 中，字节流容器的类型只要具有连续的内存存储序列即可，如 std::string。

假设现在 value 的值是十进制 125678，其二进制是 1 1110 1010 1110 1110，我们来看一下上述函数执行过程：

**第一次循环**

十六进制 0x7F 的二进制为 0111 1111，执行
> unsigned char c = (unsigned char) (value & 0x7F);

后， c = 110（十进制），二进制是 0110 1110，接着将 value 右移 7 bit，看看还有没有剩余（与 0 判断），此时 value 变为 981（十进制），对应二进制 11 1101 0101 ，代码第 9 行 if 条件为真，说明一个字节表示不了这个数值，给算出的字节 c 最高位 bit 设置标志值 1（与 0x80 做或运算，0x80 的二进制是 1000 0000，代码第 **10** 行），得到第一个字节值 238（十进制），对应二进制 1110 1110。

**第二次循环**

c 开始等于 85（十进制），执行代码第 7、8 行后，发现 value 的值仍有剩余，再次在该字节的高位设置标志 1，得到第二个字节值 213（十进制）。

**第三次循环**

c 开始等于 7，执行代码第 7、8 行后，发现 value 的值已经没有剩余，得到第三个字节值 7，然后退出循环。

程序执行过程如下图所示：
![img.png](.img/compressed-algorithm.png)

在理解了整型的压缩算法，其对应的解压算法也很容易弄明白了，代码如下，同样节选自 POCO C++ 库，代码格式略有调整：
```text
//poco-master\Foundation\src\BinaryReader.cpp
//将一个字节流中 1 ~ 5 个字节的还原成一个 uint32 整型
void BinaryReader::read7BitEncoded(UInt32& value)
{
	char c;
	value = 0;
	int s = 0;
	do
	{
		c = 0;
		_istr.read(&c, 1);
		UInt32 x = (c & 0x7F);
		x <<= s;
		value += x;
		s += 7;
	}
	while (c & 0x80);
}
```

上述代码从字节流容器 _istr 中挨个读取一个字节 ，将当前字节与 0x7F 进行与运算，以取得该字节的低 7 位内容（代码 12 行），然后再将字节内容与 0x80 进行与运算，以判断该字节的最高位是否为 1 进而进一步确定下一个字节是不是也属于整型值的内容。

同样的道理，对于 uint64 位的整型数值，我们可以将其压缩成 1 ~ 10 个字节大小的字节数组，其压缩和解压算法与 uint32 位整型值一样。

## 通信协议设计时的注意事项

### 字节对齐
前面讨论的协议示例中：
```text
// Windows（MSVC）:
#pragma pack(push, 1)
struct userinfo
{
    //版本号
    short   version;
    //命令号
    int32_t cmd;
    //用户性别
    char    gender;
    //用户昵称
    char	name[8];
    //用户年龄
    int32_t	age;
};
#pragma pack(pop)
```

```text
// Linux（GCC）:
struct userinfo
{
    //版本号
    short   version;
    //命令号
    int32_t cmd;
    //用户性别
    char    gender;
    //用户昵称
    char	name[8];
    //用户年龄
    int32_t	age;
} __attribute__((packed));
```

有一组成对的 #pragma XX 指令，其中 #pragma pack(push, n)，是告诉编译器接下来的所有结构体（这里就是 userinfo 协议）的每一个字段按 n 个字节对齐，这里 n = 1，按一个字节对齐，即去除任何 padding 字节。这样做的目的是为了内存更加紧凑，节省存储空间。

不再需要这个对齐功能后，应该使用 #pragma pack(pop) 让编译器恢复之前的对齐方式。

> 注意：#pragma pack(push, n) 与 #pragma pack(pop) 一定要成对使用，如果你漏掉其中任何一个，编译出来的代码可能会出现很多奇怪的运行结果。

### 显式指定整型字段的长度
对于一个 int 型字段，在作为协议传输时，我们应该显式地指定该类型的长度，也就是说，你应该使用 int32_t、int64_t 这样的类型来代替 int、long。之所以这么做，是因为在不同字长的机器上，对于默认的 int 和 long 的长度可能不一样，例如 long 型，在 32 位操作系统上其长度是 4 个字节，而在 64 位机器上其长度是 8 个字节。如果不显式指定这种整形的长度，可能因为不同机器字长不同，导致协议解析出错或者产生错误的结果。

### 涉及到浮点数要考虑精度问题，建议放大成整数或者使用字符串去传输
由于计算机表示浮点数存在精度取舍不准确的问题，例如对于 1.000000，有的计算机可能会得到 0.999999，在某些应用中，如果这个浮点数的业务单位比较大（如表示金额，单位为亿），就会造成很大的影响。因此为了避免不同的机器解析得到不同的结果，建议在网络传输时将浮点数值放大相应的倍数变成整数或者转换为字符串来进行传输。

### 大小端编码问题
大小端的问题（即主机字节序和网络字节序），在设计协议格式时，如果协议中存在整型字段，建议使用同一个字节序。通常的做法是在进行网络传输时将所有的整型转换为网络字节序（大端编码，Big Endian），避免不同的机器因为大小端问题解析得到不同的整型值。

当然，不一定非要转换为网络字节序，如果明确的知道通信的双方使用的是相同的字节序，则也可以不转换。

### 协议与自动升级功能
对于一个商业的产品，发布出去的客户端一般通过客户端的自动升级功能去获得更新（IOS App 除外，苹果公司要求所有的 App 必须在其 App Store 上更新新版本，禁止热更新）。在客户端与服务器通信的所有协议格式中，自动升级协议是最重要的一个，无论版本如何迭代，一定要保证自动升级协议的新旧兼容，这样做有如下原因：

- 如果新的服务器不能兼容旧客户端中的自动升级协议，那么旧的客户端用户将无法升级成新的版本了，这样的产品相当于把自己给“阉割”了。对于不少产品，不通过自动升级而让众多用户去官网下载新的版本是一件很难做到的事情，这种决策可能会导致大量用户流失；

- 退一步讲，对于一些测试不完善，或者处于快速迭代中的产品，只要保证自动升级功能正常，旧版本任何 bug 和瑕疵都可以通过升级新版本解决。这对于一些想投放市场试水，但又可能设计不充分的产品尤其重要。

> 顺便提一下，一般自动升级功能是根据当前版本的版本号与服务器端新版本的版本号进行比较，如果二者之间存在一个大版本号的差别（如1.0.0 与 2.0.0），即有重大功能更新，则应该强制客户端更新下载最新版本；如果只是一个小版本号的更新（如 1.0.0 与 1.1.0），则可以让用户选择是否更新。当然，如果是新版本修正了前一个版本中严重影响使用的 bug，也应当强制用户更新。

## 包分片
这里说的包分片，指的是应用层的对包的拆分。当一个包的数据较大，超过一个包的最长长度时，我们需要对包进行分片。有的读者可能会有疑问：分成多个包就行了，为什么要对包进行分片？在实际应用中，一般会根据业务需求对包的类型进行编号，例如使用一个 wCmd 表示业务号，但某些业务类型某次携带的数据可能比较大，超过了单个包的最大长度，这个时候我们需要将该数据拆分成多个包片，但其业务号隶属于同一个包，这就是所谓的”包分片“。

在理解了包分片的原理后，设计包分片功能也很简单了。这里提供两种包分片的思路。

1. 设置分片标志

> 在包头部分设置一个字段表示当前包是否属于某个大包的分片，分片标志字段一般有 4 种取值类型：无分片标志、包的第一个分片标志、包的最后一个分片标志、第一个分片与最后一个分片之间的包分片标志。

2. 每个包分片的包头部分有该包的总分片数目和当前分片编号。

> 对于 TCP 协议来说，由于其数据传输本身是有序的，因此多个分片，只要我们一端按顺序依次发送，另外一端收包时一定会按发送的顺序收到。因此，我们不用考虑包分片的顺序问题。

我们来看一个具体的包分片的例子：

假设现在有如下协议头定义：
```text
//与客户端交互协议包头
#pragma pack(push, 1)
typedef struct tagNtPkgHead
{
    unsigned char   bStartFlag;     //协议包起始标志 0xFF
    unsigned char   bVer;           //版本号
    unsigned char   bEncryptFlag;   //加密标志(如果不加密,则为0)
    unsigned char   bFrag;          //是否有包分片(1 有包分片 0 无包分片)
    unsigned short  wLen;           //总包长
    unsigned short  wCmd;           //命令号
    unsigned short  wSeq;           //包的序列号,业务使用
    unsigned short  wCrc;           //Crc16校验码
    unsigned int    dwSID;          //会话ID
    unsigned short  wTotal;         //有包分片时，分片总数
    unsigned short  wCurSeq;        //有包分片时，分片序号，从0开始，无分片时也为0
} NtPkgHead, *PNtPkgHead;
#pragma pack(pop)
```

对端在处理包分片的逻辑伪码如下：
```c++
UINT CSocketClient::RecvDataThreadProc(LPVOID lpParam)
{
    LOG_NORMAL("Start recv data thread.");
    DWORD           dwWaitResult;
    std::string     strPkg;
    //临时存放一个完整的包数据的变量
    std::string     strTotalPkg;
    unsigned short  uPkgLen = 0;
    unsigned int    uBodyLen = 0;
    unsigned int    uTotalPkgLen = 0;
    unsigned int    uCmd = 0;
    NtPkgHead       pkgHead;
    unsigned short  uTotal = 0;
    //记录上一次的包分片序号，包分片序号从0开始
    unsigned short  uCurSeq = 0;
    int             nWaitTimeout = 1;

    CSocketClient* pSocketClient = (CSocketClient*)lpParam;

    while (!m_bExit)
    {      
        //检测是否有数据
        if (!pSocketClient->CheckReceivedData())
        {
            //休眠10豪秒
            Sleep(10);
            continue;
        }
            
        //接收数据，并放入pSocketClient->m_strRecvBuf中
        if (!pSocketClient->Recv())
        {
            LOG_ERROR("Recv data error");
                
            //收数据出错，清空接收缓冲区，可以做一些关闭连接、重连等动作，
            pSocketClient->m_strRecvBuf.clear();

            Reconnect();
            continue;
        }

        //一定要放在一个循环里面解包，因为当前缓冲区中可能存在多个数据包
        while (true)
        {
            //判断当前收到的数据是否够一个包头大小
            if (pSocketClient->m_strRecvBuf.length() < sizeof(NtPkgHead))
                break;

            memset(&pkgHead, 0, sizeof(pkgHead));
            memcpy_s(&pkgHead, sizeof(pkgHead), pSocketClient->m_strRecvBuf.c_str(), sizeof(pkgHead));
            
            //对包消息头检验
            if (!CheckPkgHead(&pkgHead))
            {
                //如果包头检验不通过，缓冲区里面的数据已经是脏数据了，直接清空掉，
                //可以做一些关闭连接并重连的动作             
                LOG_ERROR("Check package head error, discard data %d bytes", (int)pSocketClient->m_strRecvBuf.length());
                
                pSocketClient->m_strRecvBuf.clear();

                Reconnect();
                break;
            }

            //判断当前数据是否够一个整包的大小
            uPkgLen = ntohs(pkgHead.wLen);
            if (pSocketClient->m_strRecvBuf.length() < uPkgLen)
                break;

            strPkg.clear();
            strPkg.append(pSocketClient->m_strRecvBuf.c_str(), uPkgLen);

            //从收取缓冲区中移除已经处理的数据部分
            pSocketClient->m_strRecvBuf.erase(0, uPkgLen);

            uTotal = ::ntohs(pkgHead.wTotal);
            uCurSeq = ::ntohs(pkgHead.wCurSeq);
            //无分片或第一个分片
            if (uCurSeq == 0)
            {
                strTotalPkg.clear();
                uTotalPkgLen = 0;
            }

            uBodyLen = uPkgLen - sizeof(NtPkgHead);
            uTotalPkgLen += uBodyLen;
            strTotalPkg.append(strPkg.data() + sizeof(NtPkgHead), uBodyLen);

            //无分包 或 分包的最后一个包 则将组装后的包发送出去
            if (uTotal == 0 || (uTotal != 0 && uTotal == uCurSeq + 1))
            {
                uCmd = ::ntohs(pkgHead.wCmd);

                //ProxyPackage是解析出来的业务包定义
                ProxyPackage proxyPackage;
                //拷贝业务号
                proxyPackage.nCmd = uCmd;
                //拷贝包长度
                proxyPackage.nLength = uTotalPkgLen;
                //拷贝包体内容
                proxyPackage.pszJson = new char[uTotalPkgLen];
                memset(proxyPackage.pszJson, 0, uTotalPkgLen * sizeof(char));
                memcpy_s(proxyPackage.pszJson, uTotalPkgLen, strTotalPkg.c_str(), strTotalPkg.length());

                //将一个完整的包交给业务处理
                pSocketClient->m_pNetProxy->AddPackage((const char*)&proxyPackage, sizeof(proxyPackage));
            }
        }// end inner-while-loop


    }// end outer-while-loop


    LOG_NORMAL("Exit recv data thread.");

    return 0;
}
```

上述代码在一个网络数据收取线程中，先检测是否有可读数据，如果有可读数据，则从 socket 上读取该数据存入接收缓冲区 pSocketClient->m_strRecvBuf 中，然后判断收到的数据是否够一个包头的大小（sizeof(NtPkgHead)），如果不够，退出当前循环等待后续数据到来；如果够，对包头数据进行校验后，从包头中得到整包的大小（ntohs(pkgHead.wLen)）（这里表示整包的大小的字段 wLen 使用了网络字节序，我们调用 ntohs() 函数得到本机字节序）；然后判断收到的数据是否够一个整包的大小，如果不够，退出当前循环等待后续数据到来；如果够，则根据记录当前包分片序号的变量 uCurSeq （uCurSeq = ::ntohs(pkgHead.wCurSeq)）来确定该包是否是某个分片，uCurSeq 等于 0 时说明此次从一个新的包片或完整的包开始的；从接收缓冲区中将当前包片或者完整包的数据放入变量 strTotalPkg 中存储起来（注意 pkgHead.wTotal 和 pkgHead.wCurSeq 均使用了网络字节序，需要转换成本地字节序）。接着，根据包头字段 pkgHead.wTotal 和 pkgHead.wCurSeq 转换成本机字节序的值判断这是否是一个完整的包（当 uTotal == 0 时）或者是最后一个包分片（当 uTotal != 0 && uTotal == uCurSeq + 1 时），此时 strTotalPkg 存放的就是一个完整的包数据了，接着将其拷贝出来（这里是拷贝至 ProxyPackage 结构中），进行业务逻辑处理。如果当前包片只是一个大包的中间包片，则继续进行下一轮数据的处理。strTotalPkg 中存放的数据达到一个完整的包时会在业务处理后、下一轮循环存入新的包片数据前清空掉(strTotalPkg.clear();)。

上述流程可用如下流程图表示：
![img.png](.img/send-recv-many-packages.png)

## 跨语言之间的网络通信协议识别与解析
在实际开发中，由于不同平台开发工具和编程语言的差别，我们需要不同编程语言之间去解析通信协议，这里以 C++ 和 Java 语言为例，通过一个示例来分析如何跨语言之间解析通信协议，编写跨平台代码。

这里以在 Java 中解析 C++ 网络数据包为例。 通常，这对于很多人来说是一件很困难的事情，所以只能变着法子使用第三方的库。其实只要你掌握了一定的基础知识，利用一些现成的字节流抓包工具（如 tcpdump、wireshark）很容易解决这个问题。我们这里使用 tcpdump 工具来尝试分析和解决这个问题。

首先，在我们需要明确字节序列的概念后，我们知道 x86 和 x64 系列的 CPU 使用小端编码，而数据在网络上传输，以及 Java 语言中，使用的是大端编码。 举个例子，看一个 x64 机器上的 32 位数值在内存中的存储方式，代码如下：
```c++
int main()
{
	int32_t i = 123456;
	
	return 0;
}
```

变量 i 在内存中的地址序列是 0x003CF7C4 ~ 0x003CF7C8，值为 40 e2 01 00。
![img.png](.img/endian-cpp-to-endian-java.png)

十六进制 0001e240 值等于 10 进制 123456，对于整数 123456，十万位的数字 1 是权重最高的位，个位的数字 6 是权重最低的位，小端编码中权重高的位存储在内存地址高（内存地址值大）的位置，权重值低的位存储在内存地址低（内存地址值小）的位置，这就是所谓的"高高低低原则"（高位高地址，低位低地址）。 大端编码的规则与小端编码的规则相反，大端编码使用的是"高低低高原则"，即权重高的位存储在内存地址值低的位置，权重低的位存储在内存地址高的位置。

如果我们一个 C++ 程序的 int32 值 123456 不作转换地传给 Java 程序，那么 Java 按照大端编码的形式读出来的值是：十六进制 40E20100 = 十进制 1088553216。所以，为了表达同样的值，要么在发送方将数据转换成网络字节序（big endian），要么让接收端做转换。

下面看一下如果 C++ 端传送一个类型为 msg 数据结构，Java 端该如何解析（由于 Java 中是没有指针的，也无法操作内存地址，导致很多开发者无从下手），下面利用 tcpdump 来寻找解决这个问题的思路。
```c++
#pragma pack(push, 1)
struct msg
{
	char 	compressflag;
	int32_t originsize;
	int32_t compresssize;
	char 	reservered[16];
	char 	buf[63];
}
#pragma pack(pop)
```

客户端发送的数据包：
![img.png](.img/client-send-data-packet.png)

利用 tcpdump 抓到的包如下：
![img.png](.img/tcpdump-data-packet.png)

放大一点：
![img.png](.img/tcpdump-data-packet-1.png)

白色标识出来就是我们收到的数据包。这里想说明两点：

- 如果我们知道发送端发送的字节流，再比对接收端收到的字节流，我们就能检测数据包的完整性，也可以利用这个来排查一些网络通信问题；

- 对于 Java 程序只要按照这个顺序，先利用 java.net.Socket 的输出流 java.io.DataOutputStream 对象的 readByte、readInt32、readInt32、readBytes、readBytes 方法依次读出一个 char、int32、int32、16 个字节的字节数组、63 个字节数组即可。当然，为了还原像 int32 这样的整型值，我们需要额外做一些从 little-endian 向 big-endian 的转换工作。

## xml 与 json 格式协议
xml 和 json 这两种格式由于其良好的自我解释性，是开发中使用的非常广泛的两种数据格式。一个 xml 格式的示例如下所示：
```xml
<?xml version="1.0" encoding="utf-8"?>
<SkinList>
  <Skin>
    <SkinID>0</SkinID>
    <SkinName>默认皮肤</SkinName>
    <SkinPath>Skin0\</SkinPath>
  </Skin>
  <Skin>
    <SkinID>1</SkinID>
    <SkinName>冰凉清爽</SkinName>
    <SkinPath>Skin1\</SkinPath>
  </Skin>
  <CurSkinID>0</CurSkinID>
</SkinList>
```

一个 json 格式的示例如下：
```json
{
    "userid": 1001,
    "username": "fufeng",
    "nickname": "扶风",
    "facetype": 0,
    "gender": 1,
    "birthday": 19980101,
    "signature": "生活需要很多的力气呀。xx",
    "clienttype": 1
}
```

那么 xml 和 json 格式可以单独用来作为网络通信协议吗？

当然可以，但是一般单独使用 xml 或者 json 格式作为网络通信协议的服务非常少，其原因是在给数据包分界得到一个个完整的包时非常不方便。

无论是 xml 还是 json 格式，如果单独作为协议，一般由于业务数据内容不同，每个包的长度不一样。那么在 TCP 流式数据中只能采取固定结束符的方式来分割，对于不确定长度的 xml 和 json，在频繁进行数据交换的网络通信程序中，每次解包前都得遍历一次 xml 或 json 字符串以寻找特定的包结束符。例如，对于上面的 xml 示例，就是在流式数据中寻找 </SkinList> 字符串以作为一个 xml 格式的包结束符，对于上面的 json 格式，仅仅寻找 json 结束的花括号（}）容易造成误判的，还得在这基础上加上其他限定标记，例如，json 的最后一个节点可以加一个特殊字段标志作为结束标记，以上述 json 为例，在其末尾增加一个 endFlag 标志后变成如下形式：
```json
{
    "userid": 1001,
    "username": "fufeng",
    "nickname": "扶风",
    "facetype": 0,
    "gender": 1,
    "birthday": 19980101,
    "signature": "生活需要很多的力气呀。xx",
    "clienttype": 1,
    "endFlag": 0
}
```

这样当该 json 作为一个数据包时，在判断包结束标志时可以通过寻找 "“endFlag”: 0" 加一个 “}” 这样的字符串作为包分界符号。但这种方法很不灵活，json 在某些系统或库中解析时各个字段的位置顺序可能会被调整，也就是说，像 "“endFlag”: 0" 这样的字段可能会被调整到 json 中的非末尾位置；另外 json 被格式化后某些字段值后面会被追加 “\n” 或 “\r\n” 这样的换行符，这就给程序寻找指定包结束符带来了困扰。

所以通常情况下，xml 或者 json 格式不会被单独作为协议格式，而是会作为某个协议的一部分出现，例如如下格式：
```c++
struct msg
{
	//在消息头header中说明整个包的大小，减去header、cmd和seq的大小就是buf的长度
	//即是xml或者json的长度
	msgheader header;
	int32_t	  cmd;
	int32_t   seq;
	char*     buf;	//buf是一个字符串，其格式可以是一个 xml 或者 json
};
```

> 凡事可能存在特例，业界也有使用 xml 格式的协议，例如 XMPP，有兴趣的可以通过XMPP官网了解一下。


















